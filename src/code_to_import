use crate::message::PlayerState;
use anyhow::{Context, Result};
use clerk::{DataPins4Lines, Pins};
use std::fs::File;
use std::io::prelude::*;
use tokio::{runtime, sync::watch};
extern crate hex;

mod character_pattern;



    println!("local IP address {}\r", get_local_ip_address());

    println!("router address {:?}\r", get_gateway_address());

    while let Some(next_state) = handle.block_on(player_state.recv()) {
        log::info!("next_state.current_track{:?}", next_state.current_track);

        lcd.seek(clerk::SeekFrom::Home(
            LCDLineNumbers::Line1.offset() + LCDLineNumbers::NUM_CHARACTERS_PER_LINE - 7,
        ));

        let message = if next_state.pipeline_state.is_playing() {
            format!("Vol{:>4.7}", next_state.volume)
        } else {
            format!("{:<7.7}", next_state.pipeline_state.to_string()) //if we use  next_state.pipeline_state.to_string() without the .to_string, the result can be less than 7 characters long
        };

    }

    lcd.clear();
    std::thread::sleep(std::time::Duration::from_millis(2)); // if this line is commented out, garbage or nothing appears. 1ms is marginal

    lcd.seek(clerk::SeekFrom::Home(LCDLineNumbers::Line1.offset()));

    Ok(())
}

fn get_local_ip_address() -> String {
    let mut return_value: String = String::from("bad Local IP address");
    for iface in pnet::datalink::interfaces() {
        if iface.is_up() && !iface.is_loopback() && iface.ips.len() > 0 {
            // this if statement filters off the loopback address & addresses that do not have an IP address
            for ipaddr in &iface.ips {
                let ip4addr = match ipaddr {
                    pnet::ipnetwork::IpNetwork::V4(addr) => addr.ip(), // filters off the "/24" at the end of the IP address
                    pnet::ipnetwork::IpNetwork::V6(_) => continue,
                };
                return_value = ip4addr.to_string();
            }
        }
    }
    return_value
}
pub fn get_gateway_address() -> Result<String, String> {
    /* example contents of file are shown below. If the destination is 0, the address given as the gateway is what we are looking for, but byte reversed
       Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT
       wlan0   00000000        0200A8C0        0003    0       0       303     00000000        0       0       0
       wlan0   0000A8C0        00000000        0001    0       0       303     00FFFFFF        0       0       0
    */
    if let Ok(file) = File::open("/proc/net/route") {
        let buffered_file = std::io::BufReader::new(file);
        for one_line_or_error in buffered_file.lines() {
            if let Ok(one_line) = one_line_or_error {
                let line_one_elements: Vec<&str> = one_line.split('\t').collect();
                if line_one_elements.len() > 100 && line_one_elements[1] == "00000000" {
                    match hex::decode(line_one_elements[2]) {
                        Ok(gateway_address_vec) => {
                            let gateway_address = format!(
                                "{}.{}.{}.{}",
                                gateway_address_vec[3],
                                gateway_address_vec[2],
                                gateway_address_vec[1],
                                gateway_address_vec[0]
                            );
                            return Ok(gateway_address);
                        }
                        Err(_) => return Err("Router address not hex digits".to_string()),
                    }
                }
            } else {
                return Err("Failed to read the router address".to_string());
            }
        }
        return Err("Could  not find the router address".to_string());
    } else {
        return Err("Couldn't open the file to get the address of the router".to_string());
    }
}
