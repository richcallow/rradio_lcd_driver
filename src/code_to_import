use crate::message::PlayerState;
use anyhow::{Context, Result};
use clerk::{DataPins4Lines, Pins};
use std::fs::File;
use std::io::prelude::*;
use tokio::{runtime, sync::watch};
extern crate hex;

mod character_pattern;



    println!("local IP address {}\r", get_local_ip_address());

    println!("router address {:?}\r", get_gateway_address());

    while let Some(next_state) = handle.block_on(player_state.recv()) {
        log::info!("next_state.current_track{:?}", next_state.current_track);

        lcd.seek(clerk::SeekFrom::Home(
            LCDLineNumbers::Line1.offset() + LCDLineNumbers::NUM_CHARACTERS_PER_LINE - 7,
        ));

        let message = if next_state.pipeline_state.is_playing() {
            format!("Vol{:>4.7}", next_state.volume)
        } else {
            format!("{:<7.7}", next_state.pipeline_state.to_string()) //if we use  next_state.pipeline_state.to_string() without the .to_string, the result can be less than 7 characters long
        };


        println!("\rbuf Rx by screen {}\r", next_state.buffering);
        let trimmed_buffer = next_state.buffering.min(99); //0 to 100 is 101 values, & the screen only handles 100 values, so trim downwards

        #[allow(clippy::cast_possible_wrap)]
        let scaled_buffer = (trimmed_buffer / 5) as i8; //the characters have 5 columns

        lcd.seek(clerk::SeekFrom::Home(LCDLineNumbers::Line4.offset() + 0));

        for _count in 0..scaled_buffer {
            lcd.write(' ' as u8); //first write space in all the character positions before the cursor
        }
        lcd.write((trimmed_buffer % 5) as u8); //then write the apppriate cursor character in the next position
        for _count in scaled_buffer + 1..20 {
            lcd.write(' ' as u8); //then clear the rest of the line
        }
    }

    lcd.clear();
    std::thread::sleep(std::time::Duration::from_millis(2)); // if this line is commented out, garbage or nothing appears. 1ms is marginal

    lcd.seek(clerk::SeekFrom::Home(LCDLineNumbers::Line1.offset()));

    for character in "Program shut down".chars() {
        lcd.write(character as u8);
    }

    Ok(())
}
fn get_cpu_temperature() -> i32 {
    let mut file = File::open("/sys/class/thermal/thermal_zone0/temp").unwrap_or_else(|error| {
        panic!(
            "Problem opening the CPU temperature pseudo-file: {:?}",
            error
        );
    });

    let mut cpu_temperature = String::new();

    match file.read_to_string(&mut cpu_temperature) {
        Err(why) => panic!("couldn't read the temperature from the pseduo file {}", why),
        Ok(_file_size) => {
            let milli_temp: i32 = cpu_temperature //cpu_temperature contains the temperature in milli-C and a line terminator
                .trim() //to get rid of the terminator
                .parse()
                .expect("CPU temperature was non-numeric");
            return milli_temp / 1000; //divide by 1000 to convert to C from milli-C and return the temperature
        }
    };
}
fn get_local_ip_address() -> String {
    let mut return_value: String = String::from("bad Local IP address");
    for iface in pnet::datalink::interfaces() {
        if iface.is_up() && !iface.is_loopback() && iface.ips.len() > 0 {
            // this if statement filters off the loopback address & addresses that do not have an IP address
            for ipaddr in &iface.ips {
                let ip4addr = match ipaddr {
                    pnet::ipnetwork::IpNetwork::V4(addr) => addr.ip(), // filters off the "/24" at the end of the IP address
                    pnet::ipnetwork::IpNetwork::V6(_) => continue,
                };
                return_value = ip4addr.to_string();
            }
        }
    }
    return_value
}
pub fn get_gateway_address() -> Result<String, String> {
    /* example contents of file are shown below. If the destination is 0, the address given as the gateway is what we are looking for, but byte reversed
       Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT
       wlan0   00000000        0200A8C0        0003    0       0       303     00000000        0       0       0
       wlan0   0000A8C0        00000000        0001    0       0       303     00FFFFFF        0       0       0
    */
    if let Ok(file) = File::open("/proc/net/route") {
        let buffered_file = std::io::BufReader::new(file);
        for one_line_or_error in buffered_file.lines() {
            if let Ok(one_line) = one_line_or_error {
                let line_one_elements: Vec<&str> = one_line.split('\t').collect();
                if line_one_elements.len() > 100 && line_one_elements[1] == "00000000" {
                    match hex::decode(line_one_elements[2]) {
                        Ok(gateway_address_vec) => {
                            let gateway_address = format!(
                                "{}.{}.{}.{}",
                                gateway_address_vec[3],
                                gateway_address_vec[2],
                                gateway_address_vec[1],
                                gateway_address_vec[0]
                            );
                            return Ok(gateway_address);
                        }
                        Err(_) => return Err("Router address not hex digits".to_string()),
                    }
                }
            } else {
                return Err("Failed to read the router address".to_string());
            }
        }
        return Err("Could  not find the router address".to_string());
    } else {
        return Err("Couldn't open the file to get the address of the router".to_string());
    }
}
